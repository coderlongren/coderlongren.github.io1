---
title: 异或去重
date: 2018-02-21 22:32:55
---categories:
	- Algorithm
tags:
	- Algorithm

---
来看三道题目 
*1、1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？*

当然，这道题，可以用最直观的方法来做，将所有的数加起来，减去1+2+3+…+1000的和，得到的即是重复的那个数，该方法很容易理解，而且效率很高，也不需要辅助空间，唯一的不足时，如果范围不是1000，而是更大的数字，可能会发生溢出。

我们考虑用异或操作来解决该问题。现在问题是要求重复的那个数字，我们姑且假设该数字式n吧，如果我们能想办法把1-1000中除n以外的数字全部异或两次，而数字n只异或一次，就可以把1-1000中出n以外的所有数字消去，这样就只剩下n了。我们首先把所有的数字异或，记为T，可以得到如下：

T = 1^2^3^4…^n…^n…^1000 = 1^2^3…^1000（结果中不含n）

而后我们再让T与1-1000之间的所有数字（仅包含一个n）异或，便可得到该重复数字n。如下所示：

T^(1^2^3^4…^n…^1000) = T^(T^n) = 0^n = n
*2、一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。*
```java
样例输入：2 4 3 6 3 2 5 5
样例输出：4 6
```
思路：异或去重是知道如果只有一个只出现一次的数字的求法，但这里是有两个只出现一次的数字，我们便要想办法把他分为两个子数组，每个子数组中包含一个只出现一次的数字，其他的数字都出现了两次。

首先依然从头到尾异或所有的数字，如ABCCDDEEFF，这样得到的结果就是AB异或的结果，那么在异或后的结果中找出其二进制中最右边为1的位，该位既然为1，说明AB对应的该位肯定不同，必定一个为1，一个为0，因此我们可以考虑根据此位是否为1来划分这两个子数组，这样两个只出现一次的数字就分开了

但我们还要保证出现两次的数字都分到同一个子数组中，很明显，相同的数字相同的位上的值是相同的，要么都为1，要么都为0，因此我们同样可以通过判断该位是否为1来将这些出现两次的数字划分到同一个子数组中，该位如果为1，就分到一个子数组中，如果为0，就分到另一个子数组中。

这样就能保证每个子数组中只有一个出现一次的数字，其他的数字都出现两次，分别全部异或即可得到这两个只出现一次的数字。时间复杂度为O(n)。
另外，** 所有元素异或后，在找出最右边为1的时,****X&(-X)之后得到的数字，是把X中最右边的1保留下来 **

注意，**这里的-X是X的相反数，-X是对X所有位取反+1**
```java
package 剑指offer;
/**
* @author 作者 : coderlong
* @version 创建时间：2018年2月21日 下午10:37:48
* 类说明: 
*/
public class 数组中出现一次的数字 {
	// 问题一
	public static void FindNumsAppearOnce(int[] arr)  
    {  
        int len = arr.length;
        if(len<2) {
        	return; 
        } 

        int i;  
        int AllXOR = 0;  
        //全部异或  
        for(i=0;i<len;i++) {
            AllXOR ^= arr[i];
        }

      //找出第几位为1，如010
        int res = FindFirstBit1(AllXOR);  

        int num1=0, num2 = 0;  
        for(i=0;i<len;i++)  
        {  //分成了两组
            if(IsBit1(arr[i],res)) {
                num1 ^= arr[i];  
            }
            else { 
                num2 ^= arr[i];  
            }
        }  
        System.out.println(num1+"and"+num2);
    }

    /* 
    返回num的最低位的1，其他各位都为0 
    */  
    public static int FindFirstBit1(int num)  
    {  
        //二者与后得到的数，将num最右边的1保留下来，其他位的全部置为了0  
        return num & (-num);  
    }  

    /* 
    判断data中特定的位是否为1， 
    这里的要判断的特定的位由res确定， 
    res中只有一位为1，其他位均为0，由FindFirstBit1函数返回， 
    而data中要判断的位便是res中这唯一的1所在的位 
    */  
    public static boolean IsBit1(int data,int res)  
    {  
        return ((data & res)==0) ? false:true;  
    }  

    public static void main(String[] args) {
        int[] a = { 1,1,2,2,3,44,55,55,66,66,34,34,5,5,7,7 };
        FindNumsAppearOnce(a);
    }

}

```