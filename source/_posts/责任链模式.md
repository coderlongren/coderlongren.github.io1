---
title: 责任链模式
date: 2018-1-13 22:18:40
categories:
	- 设计模式
tags:
	- 设计模式
	- Java
	- 代码重构
	- 源码学习
---
# 责任链模式 
## 定义：
使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
## 类型： 
行为类模型
如果不用责任链模式的话，代码应该是这样的写的
```
public void test(int i, Request request){  
   if(i==1){  
       Handler1.response(request);  
   }else if(i == 2){  
       Handler2.response(request);  
   }else if(i == 3){  
       Handler3.response(request);  
   }else if(i == 4){  
       Handler4.response(request);  
   }else{  
       Handler5.response(request);  
   }  
}
```
*代码臃肿*   
*耦合度高*  
*责任链模式的结构*  

责任链模式的类图非常简单，它由一个抽象地处理类和它的一组实现类组成：
抽象处理类：抽象处理类中主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest，handRequest方法的主要主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由nextHandler来处理。
具体处理类：具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。

以下代码转载自： https://mp.weixin.qq.com/s/uaVQjUu2CgVo-yL3r3RPcw
```
class Level {  
       private int level = 0;  
       public Level(int level){  
           this.level = level;  
       };  
         
       public boolean above(Level level){  
           if(this.level >= level.level){  
               return true;  
           }  
           return false;  
       }  
   }  
     
   class Request {  
       Level level;  
       public Request(Level level){  
           this.level = level;  
       }  
         
       public Level getLevel(){  
           return level;  
       }  
   }  
     
   class Response {  
     
   }  
    // 抽象类Handler
   abstract class Handler {  
       private Handler nextHandler;      
       public final Response handleRequest(Request request){  
           Response response = null;  
             
           if(this.getHandlerLevel().above(request.getLevel())){  
               response = this.response(request);  
           }else{  
               if(this.nextHandler != null){  
                   this.nextHandler.handleRequest(request);  
               }else{  
                   System.out.println("-----没有合适的处理器-----");  
               }  
           }  
           return response;  
       }  
       public void setNextHandler(Handler handler){  
           this.nextHandler = handler;  
       }  
       protected abstract Level getHandlerLevel();  
       public abstract Response response(Request request);  
   }  
     
   class ConcreteHandler1 extends Handler {  
       protected Level getHandlerLevel() {  
           return new Level(1);  
       }  
       public Response response(Request request) {  
           System.out.println("-----请求由处理器1进行处理-----");  
           return null;  
       }  
   }  
     
   class ConcreteHandler2 extends Handler {  
       protected Level getHandlerLevel() {  
           return new Level(3);  
       }  
       public Response response(Request request) {  
           System.out.println("-----请求由处理器2进行处理-----");  
           return null;  
       }  
   }  
     
   class ConcreteHandler3 extends Handler {  
       protected Level getHandlerLevel() {  
           return new Level(5);  
       }  
       public Response response(Request request) {  
           System.out.println("-----请求由处理器3进行处理-----");  
           return null;  
       }  
   }  
     
   public class Client {  
       public static void main(String[] args){  
           Handler handler1 = new ConcreteHandler1();  
           Handler handler2 = new ConcreteHandler2();  
           Handler handler3 = new ConcreteHandler3();  
     
           handler1.setNextHandler(handler2);  
           handler2.setNextHandler(handler3);  
             
           Response response = handler1.handleRequest(new Request(new Level(4)));  
       }  
   }
```
代码中Level类是模拟判定条件；Request，Response分别对应请求和响应；抽象类Handler中主要进行条件的判断，这里模拟一个处理等级，只有处理类的处理等级高于Request的等级才能处理，否则交给下一个处理者处理。  

在Client类中设置好链的前后执行关系，执行时将请求交给第一个处理类，这就是责任链模式，它完成的功能与前文中的if…else…语句是一样的。  
### 责任链模式的优缺点
责任链模式与if…else…相比，他的耦合性要低一些，因为它把条件判定都分散到了各个处理类中，并且这些处理类的优先处理顺序可以随意设定。责任链模式也有缺点，这与if…else…语句的缺点是一样的，那就是在找到正确的处理类之前，所有的判定条件都要被执行一遍，当责任链比较长时，性能问题比较严重。
### 责任链模式的使用场景
 就像开始的例子那样，假如使用if…else…语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。
 ### 总结
  责任链模式其实就是一个灵活版的if…else…语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。