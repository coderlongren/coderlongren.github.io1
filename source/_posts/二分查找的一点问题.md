---
title: 二分查找的一点问题
date: 2018-3-24 14:18:40
categories:
	- Leetcode
tags:
	- Algorithm
	- leetcode
---
摘要：二分查找的一些问题
<!-- more -->
## 原始二分查找
其中值得注意的就是 `mid = low + (high - low)/2`了， 我以前写了很久的`(low + high)/2` 知道写到一道溢出的题目，才知道。因为当low和high特别大时相加会发生Integer溢出，要么都转成long做完运算再转回来
```java
public int searchInsert(int[] nums, int target) {
        if (nums.length == 0) {
            return 0;
        }

        // MustBe(0,n-1)
        int low = 0, high = nums.length - 1;

        // MustBe(low,high): (1) Initialization: invariant holds
        while (low <= high) {

            // MustBe(low,high) and low <= high
            int mid = low + (high - low) / 2;

            // MustBe(low,high) and low <= mid <= high
            if (nums[mid] < target) {

                // MustBe(low,high) and num[mid] < target <= num[high]
                // MustBe(mid+1,high)
                low = mid + 1;

                // MustBe(low,high): (2) Preservation: invariant holds
            } else if (nums[mid] > target) {

                // MustBe(low,high) and num[low] <= target < num[mid]
                // MustBe(low,mid-1)
                high = mid - 1;

                // MustBe(low,high)
            } else {
                return mid;
            }
        } // (3) Termination: range shrinks, so it must terminate

        // low > high, so it was low = high = mid (it's impossible to get low > high if low < high)
        // 1) target < num[mid], low=mid, high=mid-1, low is the insert position
        // 2) target > num[mid], high=mid, low=mid+1, low is the insert position too!
        return low;
    }
```

## 旋转排序数组
二分查找的变种，我们一直写得都是有序数组的二分查找， 那么旋转之后的数组，你还会写吗？

	1 2 3 4 5 6 7
	| | | | | | |  
	4 5 6 7 1 2 3
```java

// 就是寻找扰乱部分
public static int search2(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        // 后半部分是有序的
        if (nums[mid] < nums[high]) {
        	// target 在这个有序范围之内
            if (nums[mid] < target && target <= nums[high]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
            
        }
        // 前半部分不是有序的
        else {
        	// target 在前半部分 （里面的） 有序范围之后， 因为前半部分的前半部分是有序的
            if (nums[low] <= target && target < nums[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}
```

## duplicate元素的影响
前面的那段程序，是不能处理重复元素的，0,0,0,1,0     
因为duplicate导致low、mid、high三者有相等情况，从而无法知道目标值在左半部分还是右半部分，
```java
// 处理duplicate元素
public static boolean search3(int[] nums, int target) {
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return true;
        }
        if (nums[mid] < nums[high]) { // 后半部分是有序的
            if (nums[mid] < target && target <= nums[high]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        } 
        else if (nums[mid] > nums[high]) {// First half may be sorted eg.[0,1,4,5,0] or all the same eg.[4,4,4,5,0]
            if (nums[low] <= target && target < nums[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        // 华丽的 地方，
        else {   // A[mid] = A[high] and A[mid]<>target, so it's safe to shrink from high bound
            high--;
        }
    }
    return false;
}
```
是不是给上一题解题过程一样的？ 不一样的地方就是那个`high--`, 对现有的数组进行shink,