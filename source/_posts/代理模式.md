---
title: 代理模式
date: 2018-1-31 14:18:40
categories:
	- 设计模式
tags:
	- 代码重构
	- 设计模式
---
<!-- more -->
## 定义
为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用
## 角色
1. *抽象角色* : 生命真实对象和代理对象的共同接口
2. *代理角色* 代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提
    供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
3. *真实角色* 代理角色所代表的真实对象，是我们最终要引用的对象。
## 分类
静态代理： 静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。

### 示例代码

抽象角色，真实对象，和代理对象共同的接口
```
public interface UserInfo{    
       public void queryUser ();    
       public void updateUser ();      
}
```
真实角色
```
public class UserImpl implementsUserInfo{    

       @Override    
       public void queryUser() {    
           //查询方法略...          
       }    

       @Override    
       public void updateUser() {    
            //修改方法略...          
       }    

}
```
代理对象
```
public class UserProxy implementsUserInfo{    
   private UserInfo userImpl;    

   public AccountProxy(UserInfo userImpl) {    
       this.userImpl = userImpl;    
   }    

   @Override    
   public void queryUser() { 
         //这里可以扩展，增加一些查询之前需要执行的方法   
       //查询方法略...   
         //这里可以扩展，增加一些查询之后需要执行的方法         
   }    

   @Override    
   public void updateUser() {  
         //这里可以扩展，增加一些修改之前需要执行的方法    
       //修改方法略...   
         //这里可以扩展，增加一些修改之后需要执行的方法         
   }  
}
```

如何使用代理类？
```
public class Test {    
   public static void main(String[] args) {    
       UserInfo userImpl = new UserImpl();     
       UserInfo userProxy = new UserProxy(userImpl);     
             userProxy.queryUser(); 
       userProxy.updateUser();        
   }    
}
```
如果要想为多个类进行代理，则需要建立多个代理类，维护难度加大。

仔细想想，为什么静态代理会有这些问题，是因为代理在编译期就已经决定，如果代理哪个发生在运行期，这些问题解决起来就比较简单，所以动态代理的存在就很有必要了。

静态代理的缺点很明显：一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行。而且，如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。这时我们可以定义这样一个代理类，它能代理所有实现类的方法调用：根据传进来的业务实现类和方法名进行具体调用。——那就是动态代理。

---

##动态代理
动态代理类的源码是程序在运行期间由JVM根据反射等机制动态生成的，所以不存在代理类的字节码文件。代理角色和真实角色的联系在程序运行时确定。
抽象角色，真实对象，和代理对象共同的接口
```
public interface Hosee {
	String sayhi();
}
```
真实角色
```
public class HoseeDynamicimpl implements Hosee {

	@Override
	public String sayhi() {
		// TODO Auto-generated method stub
		return "Welcome to coderlong's blog";
	}

}
```
代理几角色处理器
```
public class MyProxy implements InvocationHandler {

	Object obj;
	public Object bind(Object obj) {
		this.obj = obj;
		return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);
	}
	
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println(" l am a proxy");// 代理类对之进行的预处理
		Object res = method.invoke(obj, args);
		return res;
	}

}
```
测试一下
```
public class DynamicPeoxy {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		MyProxy myProxy = new MyProxy();
		HoseeDynamicimpl hoseeDynamicimpl = new HoseeDynamicimpl();
		Hosee hosee = (Hosee) myProxy.bind(hoseeDynamicimpl);
		System.out.println(hosee.sayhi());
	}

}

```
类比静态代理，可以发现，代理类不需要实现原接口了，而是实现InvocationHandler。通过
```
Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj
                .getClass().getInterfaces(), this);
```
来动态生成一个代理类，该类的类加载器与被代理类相同，实现的接口与被代理类相同。

通过上述方法生成的代理类相当于静态代理中的代理类。

这样就实现了在运行期才决定代理对象是怎么样的，解决了静态代理的弊端。

当动态生成的代理类调用方法时，会触发invoke方法，在invoke方法中可以对被代理类的方法进行增强。

通过动态代理可以很明显的看到它的好处，在使用静态代理时，如果不同接口的某些类想使用代理模式来实现相同的功能，将要实现多个代理类，但在动态代理中，只需要一个代理类就好了。

除了省去了编写代理类的工作量，动态代理实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景中。
### 动态代理的弊端
代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。

而CGLIB则可以实现对类的动态代理
*cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。*
1. 业务类 （这里也可以不实现接口）
```java
public class BookFacadeImpl1 {  
    public void addBook() {  
        System.out.println("新增图书...");  
    }  
}  
```
2. 实现 MethodInterceptor方法代理接口，创建代理类
```java
public class BookFacadeCglib implements MethodInterceptor {  
    private Object target;//业务类对象，供代理方法中进行真正的业务方法调用
  
    //相当于JDK动态代理中的绑定
    public Object getInstance(Object target) {  
        this.target = target;  //给业务对象赋值
        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类
        enhancer.setSuperclass(this.target.getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
        enhancer.setCallback(this); 
        // 创建动态代理类对象并返回  
        return enhancer.create(); 
    }
    // 实现回调方法 
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { 
        System.out.println("预处理——————");
        proxy.invokeSuper(obj, args); //调用业务类（父类中）的方法
        System.out.println("调用后操作——————");
        return null; 
    }
```
3. 创建业务类和代理类对象，然后通过  代理类对象.getInstance(业务类对象)  返回一个动态代理类对象（它是业务类的子类，可以用业务类引用指向它）。最后通过动态代理类对象进行方法调用。
```
public static void main(String[] args) {      
        BookFacadeImpl1 bookFacade=new BookFacadeImpl1()；
        BookFacadeCglib  cglib=new BookFacadeCglib();  
        BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(bookFacade);  
        bookCglib.addBook();  
    }
```
静态代理是通过在代码中显式定义一个业务实现类一个代理，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；

    JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；

    CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；