---
title: 几种排序算法
date: 2018-3-13 19:18:40
categories:
	- Algorithm
tags:
	- Algorithm
---

`插入排序`
```java
public class 插入排序 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] a = {4,2,1,3,5};
		for (int i : a) {
			System.out.print(i  + " ");
		}
		InsertSort(a);
		System.out.println();
		for (int i : a) {
			System.out.print(i  + " ");
		}
	}
	public static void InsertSort(int[] a){
		for (int j = 1;j < a.length; j++){
			// 从待插入数组中取出第一个元素
			int key = a[j];
			// i - 1 为有序数组最后一个元素，
			int i = j - 1;
			
			// 第一个条件为边界限制，第二个为插入判断条件
			while (i >= 0 && a[i] > key){
				a[i + 1] = a[i];// 若不是合适位置，有序数组向后移动
				i--;
			}
			a[i + 1] = key; // 找到合适位置，将元素插入
		}
	}

}

```

`优化的冒泡`
```java
public class 优化的冒泡排序 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] a = {4,2,1,3,5,-1,100};
		for (int i : a) {
			System.out.print(i  + " ");
		}
		sort(a);
		System.out.println();
		for (int i : a) {
			System.out.print(i  + " ");
		}
	}

	private static void sort(int[] a) {
		for (int i = 0; i < a.length - 1; i++){
			boolean flag = false; // 如果flag = true 则证明是一次也没有交换，已经排好序了 直接break
			for (int j = 0; j < a.length - 1 - i; j++){
				if (a[j] > a[j + 1]){
					int temp = a[j];
					a[j] = a[j + 1];
					a[j + 1] = temp;
					flag = true;
				}
			}
			if (!flag){
				break;
			}
		}
	}

}
```

`快排`
```java
public class 快速排序 {
	public static void main(String[] args){
		int[] a = {4,2,1,3,5,-1,100};
		for (int i : a) {
			System.out.print(i  + " ");
		}
		sort(a, 0, a.length - 1);
		System.out.println();
		for (int i : a) {
			System.out.print(i  + " ");
		}
	}
	public static int partition(int []array,int lo,int hi){
        //固定的切分方式
        int key = array[lo];
        while(lo < hi){
            while(array[hi] >= key && hi > lo){ // 从后向前，找到第一个比key小的元素
                hi--;
            }
            array[lo] = array[hi]; // 交换 
            while(array[lo] <= key && hi > lo){// 从前往后，找到一个比key大的元素
                lo++;
            }
            array[hi] = array[lo]; // 交换
        }
        array[lo] = key;
        return lo; // lo之前的  和 之后的 已经有序了。
    }
    
    public static void sort(int[] array,int lo ,int hi){
        if(lo >= hi){
            return ;
        }
        int index=partition(array,lo,hi);
        sort(array,lo,index-1);
        sort(array,index+1,hi); 
    }
}
```
